# Ch03 데이터
## C#의 데이터
  - 모든 데이터 형식의 근간을 이루는 데이터를 기본 데이터 형식(Primitive Type)
  - C#은 기본 데이터 형식을 부품으로 삼아 구성되는 복합 데이터(Complex Data Type) 형식을 지원한다.
  - 데이터는 값 형식과 참조 형식으로도 구분할 수 있다.


## 변수
변수는 코드에서 보자면 "값을 대입시켜 변화시킬 수 있는 요소"이지만,<br/>
메모리 쪽에서 보면 "데이터를 담는 일정 크기의 공간"이라는 의미를 갖기도 한다.


데이터를 만드는 것은 보통 선언한다로 표현한다.<br/>
선언의 대상은 컴파일러다.<br/>
컴파일러에게 이 변수에 필요한 메모리 공간을 예약해달라고 알리는 의미다.<br/>


## 리터럴
Literal을 사전에서 찾아보면 "문자 그대로의" 뜻을 가진 형용사이다.<br/>
컴퓨터 과학에서 리터럴(Literal)은 고정값을 나타내는 표기법을 의미한다.<br/>


## 값 형식과 참조형식
값 형식(Value Types)은 변수가 값을 담는 데이터 형식을 말하고,<br/>
참조 형식(Reference Types)은 변수가 값 대신 값이 있는 곳의 위치를 담는 데이터 형식을 말한다.<br/>


값과 관련있는 메모리 영역은 스택(Stack) 메모리 영역,<br/>
참조와 관련있는 메모리 영역은 힙(Heap) 메모리 영역이다.<br/>


## 가비지 컬렉터
스택에 쌓인 데이터들은 자신이 쓰이는 지역(코드 블록)을 벗어나면 사라지는 시점에 함께 제거된다.<br/>
코드 블록이 끝나는 시점과 상관없이 데이터를 유지하고 싶을 때는 스택의 구조가 발목을 잡는다.<br/>
그래서 프로그래머가 힙에 데이터를 올려 놓으면, 코드 블록이 종료되는 지점과 상관없이 힙에 있는 데이터는 계속 생명을 유지한다.<br/>
이 데이터는 프로그래머가 더 이상 사용하지 않는 쓰레기가 됐을 때 가비지 컬렉터가 가져다 버리고 그제서야 메모리에서 사라진다.<br/>
힙 데이터는 힙에 저장된 메모리 주소를 저장하기에 저장된 메모리의 주소를 참조한다고 참조 형식이다.<br/>


## 기본 데이터 형식
기본 데이터형식은 크게 숫자 형식, 논리 형식, 문자열 형식, 그리고 오브젝트 형식으로 나뉜다.<br/>
이 중 문자열 형식과 오브젝트 형식만 참조 형식에 해당하며, 나머지는 모두 값 형식이다.<br/>


## 정수형 숫자 데이터 형식
|데이터 형식|크기(바이트)|범위|
|:---:|:---:|:---:|
|byte|1|0 ~ 255|
|sbyte|1|-128 ~ 127|
|short|2|-32,768 ~ 32,767|
|ushort|2|0 ~ 65536|
|int|4|-2,147,483,648 ~ 2,147,483,647|
|uint|4|0 ~ 4,294,967,295|
|long|8|-922,337,203,685,477,508 ~ 922,337,203,685,477,507|
|ulong|8|0 ~ 18,446,744,073,709,551,615|
|char|2||


## 바이트
8 비트(bit)를 1 바이트(byte)로 취급한다.<br/>
그래서 1 바이트는 8개의 0과 1로 구성되는 데이터 덩어리다.<br/>


바이트는 컴퓨터가 데이터를 다루는 기본 단위이기 때문이다.<br/>
CPU가 한번에 처리하는 데이터의 크기도 바이트를 기본으로 한다.<br/>


## 2의 보수법
음수 표현가능한 정수형 데이터에서 음수를 표현하는데 맨 앞에 부호비트를 사용한다.<br/>
만약 나머지 비트는 단순히 양수처럼 나타내면 0은 두 가지 방법으로 표현된다.<br/>
그래서 2의 보수법을 사용한다.
  - 먼저 수 부분 비트를 채운다.
  - 전체 비트를 반전시킨다.
  - 반전된 비트에 1을 더한다.


## 오버플로우
데이터가 넘쳐 흐르는 경우를 말한다.


가령 byte의 최대값은 255인데 여기에 1을 더하면, 비트로 보면 1_0000_0000 이 된다.<br/>
그런데 1 바이트는 8개의 비트만 읽으므로 왼쪽 1은 못 읽고 0000_0000만 읽어 0 이된다.<br/>


## 실수형 숫자 형식 데이터
|데이터 형식|정밀도 자릿수|크기(바이트)|범위|
|:---:|:---:|:---:|:---:|
|float|7개의 자릿수만 다룰 수 있음|4|-3.402823e38 ~ 3.402823e38|
|double|15 ~ 16개의 자릿수만 다룰 수 있음|8|-1.79769313486232e308 ~ 1.79769313486232e308|
|decimal|29자리 데이터를 표현할 수 있는 소수 형식|16|±1.0 x 10e-28 ~ ±7.9 x 10e28|


여기서 e는 지수 표기법이고 3.4e38은 3.4 x 10^38을 의미한다.<br/>
실수형 데이터는 부동 소수점 연산으로 넓은 범위를 표현할 수 있지만 오차가 존재한다.<br/>
또한 실수형 데이터는 산술 연산 과정이 정수 계열 형식보다 복잡해서 느리다.<br/>


## 문자 형식
char가 2바이트라 표현했다 이는 유니코드를 따라 2바이트이다.<br/>


## 문자열 형식
프로그래밍에서 string은 문자들이 연속해서 가지런히 놓여 있는 줄을 가리킨다.<br/>
그리고 문자열은 한자어로 문자들의 연속한 하나의 줄로 묶었다는 용어다.<br/>
문자열과 string을 혼용해서 많이 사용한다.<br/>


## 논리 형식
|데이터의 형식|크기(바이트)|범위|
|:---:|:---:|:---:|
|bool|1| true, false |


bool은 1바이트 크기의 데이터 형식이다.<br/>
그런데 1비트로도 표현이 가능하다.<br/> 
하지만 컴퓨터가 기본적으로 다루는 데이터의 크기가 바이트이기 때문에 1바이트가 통째로 사용된다.<br/>


## object 형식
object는 물건, 객체라는 뜻이다.<br/>
object 형식은 어떤 데이터든지 다룰 수 있는 데이터의 형식이다.<br/>


이는 상속의 효과 덕이고 모든 데이터는 object를 상속한다.<br/>
상속은 7장에서 다룬다.<br/>


## 박싱과 언박싱
object는 참조 형식이기 때문에 힙에 데이터를 할당한다.<br/>
int 형식은 값 형식이기에 스택에 데이터를 할당한다.<br/>
그런데 int 데이터를 object 형식 객체에 담으면 값 형식의 데이터를 힙에 할당하기 위해 "박싱" 기능을 한다.<br/>
이는 object에 int 데이터를 담으면 int 데이터의 값이 힙에 새로 할당되고 object는 그 주소를 참조할 뿐이다.<br/>


언박싱은 박싱된 데이터를 꺼내 값 형식 변수에 저장하는 과정을 일컫는 단어다.<br/>


## 데이터 형식 바꾸기
변수를 다른 데이터 형식의 변수에 옮겨 담는 것을 형식 변환이라 한다.<br/>

크기(표현)범위가 다른 정수 형식 사이의 변환에서나 부호 있는 정수 형식과 부호 없는 정수 형식 사이의 변환에서는<br/>
데이터 범위가 다른 두 수를 바꾸는 경우에 이상이 일어난다.<br/>


	int x = 128;
	sbyte y = (sbyte)x;		// 오버플로우가 일어난다 127 + 1 = -128
	ushort z = (ushort)y;	// 오버플로우가 일어난다 65536 - 128 = 65408



크기(표현)범위가 다른 부동 소수점 형식 사이의 변환에서는 2진수로 표현하는 소수는 완벽하지 않다.<br/>
그래서 오차가 발생한다.<br/>


	float a = 0.1f;			// 0.1
	double b = (double)a;		// 0.10000000149011612



부동 소수점과 형식 정수 형식 사이의 변환에서는 소수점 부분을 버린다.<br/>


	float a = 1.1f;
	int b = (int)a;	// 1


문자열과 숫자 사이의 변환에서는 오차범위 안인 경우 이상없이 저장된다.<br/>


## 상수
변수는 담고 있는 데이터를 얼마든지 변경할 수 있는 메모리 공간이다.<br/>
상수는 절대 바꾸면 안되는 변수에 한해 선언한다.<br/>
프로그래머도 사람이기에 바꾸는 실수를 할 수 있다.<br/>
이 때 상수 선언을 하면 컴파일러가 바꾸면 안된다고 프로그래머에게 알려준다.<br/>


## 열거 형식
상수를 여러개 선언해야 할 때 사용하는 데이터 형식이다.<br/>
열거형 상수에 초기 값을 할당 할 수 있다.<br/>
따로 값을 할당하지 않으면 시작지점은 0으로 채우고 이후부터는 이전 값 + 1을 채워간다.<br/>


	enum TYPE { A, B, C = 0, D, E };


라 선언하면 TYPE.A = 0, TYPE.B = 1, TYPE.C = 0, TYPE.D = 1, TYPE.E = 2이다.<br/>


## Nullable 형식
프로그래밍 하다보면 값도 가지지 않는 변수가 필요할 때가 있다.<br/>
이 때 사용하는 데이터 형식이다.<br/>


	int? a;


와 같이 선언할 수 있다.<br/>
Nullable은 struct 자료형이고 값이 없음을 HasValue 멤버로 확인할 수 있다.<br/>
그리고 값이 있는 경우 Value 멤버로 확인 가능하다.<br/>


## var
C#은 변수나 상수에 대해 깐깐하게 형식 검사를 하는 강력한 형식의 언어이다.<br/>
강력한 형식 검사는 프로그래머의 실수를 줄여 준다.<br/>

약한 형식 검사는 코드를 작성함에 있어 편리하다.<br/>
var를 사용해 변수를 선언하면 컴파일러가 자동으로 해당 변수의 형식을 지정해준다.<br/>
단 var 형식은 초기화를 해줘야 컴파일러가 추론할 수 있으며, 지역변수로만 사용할 수 있다.<br/>


	short a = 10;
	var b = 1_000_000;		// int
	var c = a;			// short
	var d = 1.124f;		// float
	object e = 100;		// object


정수 리터럴의 경우 int 범위 안이면 int로 컴파일 한다.<br/>
오브젝트 자료형은 오브젝트 형식일 뿐이다!<br/>


## 공용 형식 시스템
C#에서는 char, int, long, double, string, object와 같이 다양ㅇ한 기본 데이터 형식을 지원한다.<br/>
프로그래머는 이를 조합해서 복합 데이터 형식을 만들어 사용한다.<br/>
또한 스택과 힙이라는 두 가지 메모리 영역을 사용해서 변수의 생명주기에 따라 변수를 값이나 참조 형식으로 만들어 사용할 수 있다.<br/>
그런데 C#의 모든 데이터 형식 체계는 C#의 고유의 것이 아니다.<br/>

공용 형식 시스템(Common Type System, CTS)이라는 .NET의 형식 체계표준을 그대로 따르고 있을 뿐이다.<br/>
공용 형식 시스템은 모두가 함께 사용하는 데이터 형식 체계라는 의미이다.<br/>

언어간의 호환성은 프로그래머들이 하나로 뭉치게 하거나 각 분야에 강점을 보이는 것들을 모아 조합하여 만드는데 도움이 된다.<br/>
모든 데이터 형식에 관련되 이야기가 곧 CTS의 이야기다.<br/>


|클래스 이름|C# 형식|C++ 형식|
|:---:|:---:|:---:|
|System.Byte|byte|unsigned char|
|System.SByte|sbyte|char|
|System.Int16|short|short|
|System.Int32|int|int 또는 long|
|System.Int64|long|__int64|
|System.Single|float|float|
|System.Decimal|decimal|decimal|
|System.Object|object|Object\*|
|system.String|string|String\*|


## 문자열
문자열 안에서 찾는 함수들이다.


|메소드|기능|
|:---:|:---|
|IndexOf()|현재 문자열 내에서 찾고자 하는 지정된 문자 또는 문자열의 시작 위치를 찾는다.|
|LastIndexOf()|현재 문자열 내에서 찾고자 하는 지정된 문자 또는 문자열의 시작 위치를 뒤에서부터 찾는다.|
|StartWith()|현재 문자열이 지정된 문자열로 시작하는지를 판단한다.|
|EndsWith()|현재 문자열이 지정된 문자열로 끝나는지를 판단한다.|
|Contains()|현재 문자열이 지정된 문자열을 포함하는지를 판단한다.|
|Replace()|현재 문자열에서 지정된 문자열이 다른 지정된 문자열로 모두 다뀐 새 문자열을 반환한다.|


문자열 변형하는 함수들이다.


|메소드|기능|
|:---:|:---|
|ToLower()|현재 문자열의 모든 대문자를 소문자로 바꾼 새 문자열을 반환한다.|
|ToUpper()|현재 문자열의 모든 소문자를 대문자로 바꾼 새 문자열을 반환한다.|
|Insert()|현재 문자열의 지정된 위치에 지정된 문자열이 삽입된 새 문자열을 반환한다.|
|Remove()|현재 문자열의 지정된 위치로부터 지정된 수만큼 문자가 삭제된 새 문자열을 반환한다.|
|Trim()|현재 문자열의 앞, 뒤에 있는 공백들을 모두 삭제한 새 문자열을 반환한다.|
|TrimStart()|현재 문자열의 앞에 있는 공백들을 모두 삭제한 새 문자열을 반환한다.|
|TrimEnd()|현재 문자열의 뒤에 있는 공백들을 모두 삭제한 새 문자열을 반환한다.|


문자열 분할하는 함수들이다


|메소드|기능|
|:---:|:---|
|Split()|지정된 문자를 기준으로 현재 문자열을 분리한 다음 분리한 문자열의 배열을 반환한다.|
|SubString()|현재 문자열의 지정된 위치로부터 지정된 수만큼의 문자로 이루어진 새 문자열을 반환한다.|


## 문자열 서식 맞추기
여기서 말하는 서식이란 문자열이 일정한 틀과 모양을 갖추는 것을 의미한다.<br/>
C#은 문자열 서식화에 사용할 수 있는 간편한 두 가지 기능을 제공한다.<br/>

  - Format() 메소드
  - 문자열 보간(Interpolation)

두 방법 모두 문자열 틀을 두고, 그 틀을 이용해서 서식화된 새로운 문자열을 만들어낸다는 공통점이 있다.<br/>


## Format() 메소드
사용 형식은 다음과 같다.<br/>


	{ 첨자, 맞춤:서식 문자열 }


  - 첨자는 서식항목의 첨자를 의미한다.
  - 맞춤은 오른쪽 맞춤, 왼쪽 맞춤을 의미한다.
  - 서식 문자열은 변환 서식 지정 문자열이다.

먼저 맞춤을 본다.<br/>
맞춤 자리에 숫자를 지정하면 항목이 차지할 공간의 크기를 지정할 수 있다.<br/>
해당 공간보다 많은 문자열이 입력되면 공간은 문자열의 크기에 맞춰 늘어난다.<br/>

그리고 크기의 값이 양수이면 오른쪽 끝에 붙어서 문자열을 출력한다.<br/>


	Console.WriteLine(string.Format("{0, 10}END", "START"));


라 하면 다음과 같이 출력된다.<br/>

|0|[1]|[2]|[3]|[4]|[5]|[6]|[7]|[8]|[9]|[10]|[11]|[12]|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
||||||S|T|A|R|T|E|N|D|

