# Ch04 연산자
## C#에서 제공하는 연산자

|분류|연산자|
|:---:|:---|
|산술 연산자| +, -, \*, /, % |
|증가/감소 연산자| ++, -- |
|관계 연산자| <, >, ==, !=, <=, >= |
|조건 연산자| ?: |
|null 조건부 연산자| ?., ?[] |
|논리 연산자|&&, \|\|, ! |
|비트 연산자| <<, >>, &, \|, ^, ~ |
|할당 연산자| =, +=, -=, \*=, /=, %=, &=, \|=, ^=, <<=, >>= |
|null 병합 연산자| ?? |

위 표에 있는 연산자들 중 대부분은 특정 형식에서만 사용이 가능하다.<br/>
산술 연산자의 /는 모든 수치 데이터 형식에 사용이 가능하지만, 문자열 형식에는 사용할 수 없다.<br/>


## 산술 연산자
산술 연산자(Arithmetic Operation)는 수치 형식의 데이터를 다루는 연산자이다.

|연산자|설명|
|:---:|:---|
|+|양쪽 피연산자를 더한다.|
|-|왼쪽 피연산자에서 오른쪽 피연산자를 뺀다.|
|\*|양쪽 피연산자를 곱한다.|
|/|왼쪽 피연산자를 오른쪽 피연산자로 나눈다.|
|%|왼쪽 피연산자를 오른쪽 피연산자로 나눈 후 나머지를 구한다.|


## 증가 연산자와 감소 연산자
  - 증가 연산자(Increment Operator) ++는 피연산자의 값을 1 증가시킨다.
  - 감소 연산자(Decrement Operator) --는 피연산자의 값을 1 감소시킨다.

증가 연산자와 감소 연산자는 수치 형식의 데이터 뿐만 아니라 열거 형식의 데이터에도 사용할 수 있다.<br/>

|연산자|설명|
|:---:|:---|
|++|피연산자의 값을 1 증가 시킨다.|
|--|피연산자의 값을 1 감소 시킨다.|


증가 연산자와 감소 연산자는 변수의 앞에 사용하면 전위, 변수의 뒤에 사용하면 후위로 나뉜다.<br/>
그리고 전위인지 후위인지에 따라 기능이 나뉜다. 전위나 후위가 1개인 경우 다음과 같이 생각할 수 있다.<br/>


	int a = 5;
	Console.WriteLine(a++);	// 5
	// Console.WriteLine(a);
	// a = a + 1;	

	Console.WriteLine(++a);	// 7
	// a = a + 1;
	// Console.WriteLine(a);


전위의 경우 해당 코드 줄에서 기능이 가장 먼저 실행되고, 후위의 경우 기능이 가장 마지막에 실행된다고 보면 된다.<br/>


## 문자열 결합 연산자
문자열에서 +연산자는 결합 연산자가 된다.<br/>
결합 연산자는 왼쪽 문자열의 끝에 오른쪽 문자열을 이어 붙여 새로운 문자열을 반환한다.<br/>


## 관계 연산자
관계 연산자(relational Operator)는 두 피연산자 사이의 관계를 평가하는 연산자이다.<br/>
C#이 제공하는 관계 연산자는 다음과 같다.<br/>


|연산자|설명|
|:---:|:---|
|<|왼쪽 피연산자가 오른쪽 피연산자보다 작으면 참, 아니면 거짓|
|>|왼쪽 피연산자가 오른쪽 피연산자보다 크면 참, 아니면 거짓|
|<=|왼쪽 피연산자가 오른쪽 피연산자보다 작거나 같으면 참, 아니면 거짓|
|>=|왼쪽 피연산자가 오른쪽 피연산자보다 크거나 같으면 참, 아니면 거짓|
|==|왼쪽 피연산자와 오른쪽 피연산자와 같으면 참, 아니면 거짓|
|!=|왼쪽 피연산자와 오른쪽 피연산자가 다르면 참, 아니면 거짓|


<, >, <=, >=는 모든 수치 형식과 열거 형식에서 사용할 수 있다<br/>
==, !=는 모든 데이터 형식에서 사용 가능하다.<br/>


## 논리 연산자
논리 연산자(Logical Operation)은 참과 거짓으로 이루어지는 진릿값이 피연산자인 연산을 말한다.<br/>
C#에서 제공하는 논리 연산자는 다음과 같다.<br/>

|연산자|설명|
|:---:|:---|
| && |양쪽 피연산자가 모두 참이면 참, 아니면 거짓|
| \|\| |양쪽 피연산자가 모두 거짓이면 거짓, 아니면 참|
| ! |피연산자가 참이면 거짓, 아니면 참|


## 조건 연산자
조건 연산자(conditional Operator)는 피연산자가 세 개나 된다.<br/>


	조건식 ? 참일_때의_값 : 거짓일_때의_값


형태로 사용한다.<br/>
조건 연산자의 첫 번째 매개변수인 조건식은 결과가 참 또는 거짓인 논리값이어야 한다.<br/>
조건식의 결과가 참이면 두 번째 매개변수가 선택되고, 조건식의 결과가 거짓이면 세 번째 매개변수가 선택된다.<br/>


## null 조건부 연산자
널(null) 조건부 연산자 ?.는 C# 6.0에서 도입되었다.<br/>
?. 연산자는 객체의 멤버에 접근하기 전에 해당 객체가 null인지 검사한다.<br/>
객체가 null이면 null을 반환하고, 객체가 null이 아니면 멤버에 접근한다.<br/>


?[] 연산자 역시 비슷한 기능을 수행한다.<br/>
?[]는 배열과 같은 컬렉션 객체의 첨자를 이용한 참조에 사용된다.<br/>
객체가 null이면 null을 반환하고, 객체가 null이 아니면 인덱스에 해당하는 값을 반환한다.<br/>


## 비트 연산자
컴퓨터는 원래 0과 1의 비트 데이터만 다루는 기계이다.<br/>
그런데 지금까지 사용한 데이터는 바이트 크기의 데이터만 다뤄왔다.<br/>
32 곳의 아이템 착용 여부 확인을 할 때, bool 을 32개 할당해 32바이트로 확인할 수 있다<br/>
int 자료형에 비트 단위로 기록하면 4바이트로 확인 가능하다.<br/>
이처럼 비트 수준의 데이터를 다루는게 필요한 경우도 있다.<br/>
이 때 사용하는 것이 비트 연산자이다.<br/>
C#에서 제공하는 비트 연산자이다.

|연산자|이름|기능|
|<<|왼쪽 시프트 연산자|첫 번째 피연산자의 비트를 두 번째 피연산자의 수만큼 왼쪽으로 이동시킨다.|
|>>|오른쪽 시프트 연산자|첫 번째 피연산자의 비트를 두 번째 피연산자의 수만큼 오른쪽으로 이동시킨다.|
|&|논리곱(AND) 연산자|두 피연산자의 비트 논리곱을 수행한다.|
|\||논리합(OR) 연산자|두 피연산자의 비트 논리합을 수행한다.|
|^|배타적 논리합(XOR) 연산자|두 피연산자의 비트 배타적 논리합을 수행한다.|
|~|보수(NOT) 연산자|피연산자의 비트를 0은 1로, 1은 0으로 반전시키는 단항 연산자이다.|


## 시프트 연산자
시프트 연산자(Shift Operator)는 비트를 왼쪽이나 오른쪽으로 이동시키는 연산자라고 할 수 있다.<br/>
다음과 같이 8비트 정수 자료형이 있다고 생각하자.<br/>

|[7]|[6]|[5]|[4]|[3]|[2]|[1]|[0]|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0|1|1|0|1|0|

여기서 왼쪽 시프트 << 1을 하면 왼쪽으로 1칸 이동 시킨다.<br/>

|[7]|[6]|[5]|[4]|[3]|[2]|[1]|[0]|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|1|1|0|1|0|0|

처럼 변한다.<br/>
왼쪽 시프트 연산에서 빈 공간은 0으로 채운다.<br/>
밀려나온 비트는 버린다.<br/>

옮기는 칸을 의미하는 오른쪽 피연산자는 int 자료형만 가능하다.
그리고 옮기는 칸이 왼쪽 피연산자의 비트 크기 범위보다 큰 경우,<br/>
옮기는 칸을 왼쪽 피연산자의 비트 크기로 나눈 나머지로 변환해 이동한다.<br/>
음수인경우는 왼쪽 피연산자의 비트 크기 값을 더해 음이아니게 만들어 진행한다고 보면 된다.<br/>


|[7]|[6]|[5]|[4]|[3]|[2]|[1]|[0]|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0|1|1|0|1|0|

여기서 오른쪽 시프트 >> 1을 하면 오른쪽으로 1칸 이동 시킨다.<br/>

|[7]|[6]|[5]|[4]|[3]|[2]|[1]|[0]|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|1|1|0|1|

처럼 변한다.<br/>
오른쪽 시프트 연산에서는 빈 공간은 부호 비트에 맞춰 채운다. 현재는 0이므로 0을 채운다.<br/>
그리고 오른쪽 끝에 밀려난 비트는 버린다.<br/>


## 비트 논리 연산자
다음과 같이 두 8 비트 데이터에 대해 연산한다고 생각하자.<br/>

|[7]|[6]|[5]|[4]|[3]|[2]|[1]|[0]|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|1|1|0|1|
|0|1|0|0|1|0|0|1|


논리곱 연산자(&)를 하면, 각 자리의 비트에 대해 모두 1로 같으면 1로 채우고 아니면 0을 채운다.<br/>


|[7]|[6]|[5]|[4]|[3]|[2]|[1]|[0]|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|1|1|0|1|
|0|1|0|0|1|0|0|1|
|0|0|0|0|1|0|0|1|


그래서 비트 상태는 00001001이 된다<br/>


논리합 연산자(\|)를 하면, 각 자리의 비트에 대해 모두 0으로 같으면 0을 채우고 아니면 1을 채운다.<br/>

|[7]|[6]|[5]|[4]|[3]|[2]|[1]|[0]|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|1|1|0|1|
|0|1|0|0|1|0|0|1|
|0|1|0|0|1|1|0|1|


그래서 비트 상태는 01001101이 된다.<br/>


배타적 논리합 연산자(^)을 하면 두 비트자리가 같으면 0을 다르면 1로 채운다.<br/>

|[7]|[6]|[5]|[4]|[3]|[2]|[1]|[0]|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|1|1|0|1|
|0|1|0|0|1|0|0|1|
|0|1|0|0|0|1|0|0|


그래서 비트 상태는 01000100이 된다.<br/>


보수 연산자(~)는 단항 연산자이므로 피연산자가 한 개다.

|[7]|[6]|[5]|[4]|[3]|[2]|[1]|[0]|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|1|1|0|1|


해당 비트상태에 보수 연산자를 하면 0인 경우는 1로 1인 경우는 0으로 바꾼다.<br/>

|[7]|[6]|[5]|[4]|[3]|[2]|[1]|[0]|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|1|1|0|1|
|1|1|1|1|0|0|1|0|


## 할당 연산자
할당 연산자(Assignment Operator)는 변수 또는 상수에 피연산자 데이터를 할당하는 기능을 한다.<br/>

|연산자|기능|
|:---:|:---|
|=|오른쪽 피연산자를 왼쪽 피연산자에 할당한다.|
|+=| a += b 는 a = a + b와 같다.|
|-=| a -= b는 a = a - b와 같다.|
|\*=| a \*= b는 a = a \* b와 같다.|
|/=| a /= b는 a = a / b와 같다.|
|%=| a %= b는 a = a % b와 같다.|
|&=| a &= b는 a = a & b와 같다.|
|\|=| a \|= b는 a = a \| b와 같다.|
|^=| a ^= b는 a = a ^ b와 같다.|
|<<=| a <<= b는 a = a << b와 같다.|
|>>=| a >>= b는 a = a >> b와 같다.|


## null 병합 연산자
null 병합 연산자 ?? 는 변수, 객체의 null 검사를 간결하게 만들어 주는 역할을 한다.<br/>


	int? a = null;
	Console.WriteLine(a ?? 0);	// 0

	a = 1;
	Console.WriteLine(a ?? 0);	// 1


변수 또는 객체가 null이면 오른쪽 피연산자의 값을, null이 아니면 왼쪽 피연산자의 값을 반환한다.<br/>


## 연산자의 우선순위
연산자에도 우선순위가 있다.<br/>

|우선순위|연산자|
|:---:|:---|
|1|후위++/-- 연산자, ?., ?[]|
|2|전위++/-- 연산자|
|3|\*, /, %|
|4|+, -|
|5|시프트 연산자 <<, >>|
|6|관계 연산자 <, >, >=, <=, is, as |
|7|관계 연산자 ==, != |
|8|&|
|9|^|
|10|\||
|11|&&|
|12|\|\||
|13|??|
|14|?:|
|15|할당 연산자 =, \*=, /=, %=, +=, -=, <<=, >>=, &=, \|=, ^=|


후위 연산자의 우선순위가 높다. 후위 연산자가 1개인 경우 작동되는 기능은 가장 뒤에 연산된다고 생각하면 된다.<br/>
한 줄의 코드에 하나의 변수에 후위 연산자를 2번 쓰는 경우는 후위 연산자가 어떻게 작동하는지 알아야 한다.<br/>
후위 연산자를 함수로 만들어 보면 다음과 같다<br/>


	int OperatorPP(ref int _n)
	{

	    int ret = _n;
	    _n += 1;
	    return ret;
	}
