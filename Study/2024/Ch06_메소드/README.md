# Ch06 메소드
## 메소드
메소드(Method)는 객체지향 프로그래밍 언어에서 사용하는 용어로,<br/>
C와 C++ 언어에서는 함수(Function)라 불렀고<br/>
파스칼에서는 프로시저(Procedure)라고 불렀다.<br/>
혹은 서브루틴(Subroutine)이나 서브 프로그램(Subprogram)이라 부르는 언어도 있다.<br/>
엄밀히는 의미 차이가 존재하지만, 큰 맥락에서는 이 용어들은 같은 것을 지칭한다.<br/>


메소드는 일련의 코드를 하나의 이름 아래 묶은 것이다.<br/>
메소드 이름을 불러 실행할 수 있다.(메소드 호출)<br/>
메소드 형식은 아래와 같다<br/>


	한정자 반환_형식 메소드_이름 ( 매개변수_목록 )
	{

		// 실행하고자 하는 코드들
		...


		// 메소드 결과의 데이터 형식은 메소드 반환 형식과 일치해야 한다.
		return 메소드_결과
	}


메소드는 클래스 안에 존재한다.<br/>
C#은 객체지향 프로그래밍 언어이고, 객체지향 프로그래밍에서는 코드 내의 모든 것을 객체로 표현한다.<br/>
객체는 자신만의 속성(데이터)과 기능(메소드)을 갖고 있다.<br/>
클래스가 바로 이 객체를 위한 청사진을 제공한다.<br/>


## 매개변수
매개변수(Parameter)는 메소드에 넣는 재료라고 볼 수 있다.<br/>
메소드를 실행하면 인수(Argument)를 넘기고, 이 인수는 메소드의 매개변수에 입력된다.<br/>

매개변수는 메소드가 호출자에게서 전달받은 값을 받는 변수를 말하고,<br/>
인수는 호출자가 매개변수에 넘기는 값을 뜻한다.<br/>


## 반환 형식
반환 형식은 메소드가 실행되면 나오는 결과로 보면 된다.<br/>
어떤 메소드들은 자기 할 일만 끝내고 반환 없이 종료하는 메소드도 있다.<br/>
Console 클래스에 WriteLine() 메소드가 하나의 예다.<br/>
이런 메소드를 선언할 때는 반환 형식에 void를 넣어주면 된다.<br/>


## static
static은 사전적으로는 "정적"이라는 의미를 갖고 있다.<br/>
움직이지 않는다는 뜻이다.<br/>
C#에서는 static은 메소드나 필드가 클래스의 인스턴스가 아닌 클래스 자체에 소속되도록 지정하는 한정자이다<br/>
나머지는 7장에서 다룬다.<br/>


## return
return은 점프문의 한 종류이다.<br/>
return 문은 언제든지 메소드 중간에 호출되어 메소드를 종결시키고 프로그램의 흐름을 호출자에게 돌려줄 수 있다.<br/>


## 재귀 호출
메소드가 자기 자신을 스스로 호출하는 것을 일컬어 재귀 호출(Recursive Call)이라고 한다.<br/>
재귀 호출은 코드를 단순하게 구성할 수 있다는 장점이 있다.(재귀 호출이 없다면 반복문으로 구성해야 한다.)<br/>
반면 성능에는 나쁜 영향을 주기 때문에 주의해서 사용해야 한다.<br/>


## 매개변수
매개변수는 메소드 외부로부터 메소드 내부로 데이터를 전달 받는 매개체 역할을 할 뿐이다.<br/>
매개변수는 근복적으로 변수이기에 한 변수를 다른 변수에 할당하면 변수가 담고 있는 데이터만 복사될 뿐이다.<br/>
그 데이터가 값이던 참조던 상관 없이 말이다<br/>


메소드 안에서 매개변수를 수정한다고 해서, 별개의 메모리 공간을 사용하기에 전달했던 변수에는 아무런 영향을 주지 않는다.<br/>
전달했던 변수에 영향을 주고 싶다면 참조에 의한 전달(Pass by reference)로 넘기면 된다.<br/>


값에 의한 전달이 매개변수가 변수나 상수로부터 값을 복사하는 것과 달리,<br/>

## ref
참조에 의한 전달은 매개변수가 메소드에 넘겨진 원본 변수를 직접 참조한다.<br/>
따라서 메소드 안에서 매개변수를 수정하면 이 매개변수가 참조하고 있는 원본 변수에 수정이 이뤄진다.<br/>
메소드 정의에서 매개변수 앞에 ref 키워드를 넣고 함수 호출 시 매개변수 앞에도 ref 키워드를 추가하면 된다.<br/>


	한정자 반환_형식 메소드_이름 ( 매개변수_목록, ref 참조할_매개변수, 매개변수_목록 )
	{

	    ...
	    return ...;	
	}


	static void Main(string[] args)
	{
	
	    ...
	    메소드_이름( ..., ref 매개변수, ...);
	    ...
	}


마찬가지로 메소드의 결과를 참조로 반환할 수 있다.<br/>


	한정자 ref 반환_형식 메소드_이름 ( 매개변수_목록 )
	{

	    ...
	    return ref 반환값;
	}


	static void Main(string[] args)
	{

	    ...
	    ref 반환_형식 변수명 = ref 메소드_이름 ( 매개변수_목록 );
	    ...
	}


참조 반환 값은 메소드 안에서 만들어진 지역변수나 리터럴 상수 같은 값으로 선언할 수 없다.<br/>


## out
대개의 경우 메소드의 결과는 하나면 충분하다.<br/>
그러나 두 개 이상의 결과를 요구하는 특별한 메소드도 있다.<br/>
이 경우 ref 키워드를 이용해 두 가지 경우를 반환할 수 있다.<br/>
ref 변수를 이용하는 경우 해당 변수에 할당하지 않아도 컴파일러는 잡지 않는다.<br/>

그런데 out 키워드를 이용해서도 반환이 가능하다.<br/>
out 키워드는 할당하지 않으면 컴파일 에러를 일으켜 안정성이 올라간다.<br/>
하지만 다음과 같은 경우에 사용할 수 없다.<br/>


  - out은 비동기 메소드에서 허용되지 않는다.
  - 매개변수의 반복기에서는 허용되지 않는다.
  - 속성을 out 변수로 전달할 수 없다.


## 오버로딩
메소드 오버로딩은 하나의 메소드 이름에 여러 개의 구현을 올리는 것을 뜻한다.<br/>
매개변수의 수와 형식을 분석해서 어떤 버전이 호출될지를 찾아준다.<br/>
반환형은 중요하지 않다.<br/>
실행할 메소드의 버전을 찾는 작업이 컴파일 타임에 이뤄지므로 성능저하는 걱정하지 않아도 된다.<br/>


## 가변 개수의 인수
개수가 다르다는 이유만으로 똑같은 메소드를 여러 가지 버전으로 오버로딩하고 싶을 때가 있다.<br/>
이런 경우에 C#은 가변 개수의 인수라는 기능을 제공한다.<br/>
가변 개수의 인수란, 그 개수가 유연하게 변할 수 잇는 인수를 말한다.<br/>


가변 개수의 인수는 params 키워드와 배열을 이용해서 선언한다.<br/>
이렇게 구현한 메소드는 인수의 개수를 달리해서 호출할 수 있다.<br/>


메소드 오버로딩은 형식이 다른 경우에 사용할 수 있어<br/>
매개변수의 개수가 유한하게 정해져 있다면 가변 개수의 인수보다는 메소드의 오버로딩을 사용하는 것이 적절하다.<br/>
가변 개수의 인수는 형식은 같으나 인수의 개수만 유연하게 달라질 수 있는 경우에 적합하다.<br/>

params 매개변수의 인수 목록은 맨 마지막에 위치해야 한다.<br/>


## 명명된 인수
메소드를 호출할 때 매개변수 목록 중 어느 매개변수에 데이터를 할당할지 지정하는 것은 순서다<br/>
대개의 경우 순서에 근거해서 매개변수에 인수를 할당하는 스타일을 사용하지만,<br/>
C#은 명명된 인수라는 또 다른 스타일도 지원한다.<br/>
메소드를 호출할 때 인수의 이름 뒤에 콜론(:)을 붙인 뒤 그 뒤에 할당할 데이터를 넣어주면 된다.<br/>
인수가 너무 많은 경우 어느 매개변수에 어느 인수를 할당하고 있는지 분간이 어려울 때 사용하면 가독서잉 좋아진다.<br/>


## 선택적 인수
메소드의 매개변수는 기본값을 가질 수 있다.<br/>
그래서 매개변수를 특정 값으로 초기화하듯 메소드를 선언할 수 있다.<br/>

기본값을 가진 매개변수는 메소드를 호출할 때 해당 인수를 생략할 수 있다.<br/>
물론 필요에 따라 할당하거나 할당하지 않을 수 있기 때문에 이를 선택적 인수(Optional Argument)라 부른다.<br/>

매개변수가 많고 선택적 인수도 여럿 포함되면 명명된 인수를 사용하면 가독성이 좋아진다.<br/>

선택적 인수는 상당히 유용한 기능이지만 메소드의 오버로딩과 함께 사용될 때 혼란을 야기할 수 있다.<br/>


	void Method(int a = 0) { Console.WriteLine("int"); }
	void Method() { Console.WriteLine("void"); }


위와 같이 선택적 인수와 오버로딩을 함께 사용해 Method()를 호출하는 경우,<br/>
정의 순서를 바꿔도 void가 출력됨을 알 수 있다.<br/>
오버로딩을 할지 선택적 인수를 사용할지를 프로그래머가 정책적으로 분명하게 정할 필요가 있다.<br/>


예를들어, 논리는 동일하되 매개변수가 다른 경우는 선택적 인수를 사용하고,<br/>
매개변수에 따라 논리도 함께 달라지는 경우에는 오버로딩을 사용하는 식으로 말이다<br/>


## 로컬 함수
로컬 함수(Local Function)는 메소드 안에서 선언되고,<br/>
선언된 메소드 안에서만 사용되는 특별한 함수이다.<br/>
클래스의 멤버가 아니기 때문에 메소드가 아니라 함수(Function)라고 부른다.<br/>
선언 방법은 메소드와 다르지 않지만, 로컬 함수는 자신이 존재하는 지역에 선언되어 있는 변수를 사용할 수 있다.<br/>

로컬 함수는 메소드 밖에서는 다시 쓸 일 없는 반복적인 작업을 하나의 이름 아래 묶어 놓는데 제격이다.<br/>
람다식과 더불어 프로그래머에게 코드를 간추릴 수 있는 또 하나의 옵션을 제공하는 것이다.<br/>