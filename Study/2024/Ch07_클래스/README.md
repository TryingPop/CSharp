# Ch07 클래스
## 객체지향 프로그래밍
클래스를 이야기하려면, 먼저 객체지향 프로그래밍(Object Oriented Programming)을 설명해야 한다.<br/>
객체지향 프로그래밍은 OOP라고도 하는데, 코드 내의 모든 것을 객체(Object)로 표현하고자 하는 프로그래밍 패러다임을 뜻한다.<br/>
객체는 컴퓨터, 키보드, 유니티 공부 등 모든 것을 지칭하는 단어다.<br/>


객체에는 크게 두 가지 특징이 있다.<br/>
하나는 속성이고 다른 하나는 기능이다.<br/>

속성은 데이터로, 기능은 메소드로 표현하면 된다.<br/>
정리하면 객체는 데이터와 메소드로 이루어진 것이다.<br/>


## 클래스
클래스는 객체를 만들기 위한 청사진이다.<br/>
클래스는 객체가 가지게될 속성과 기능을 정의하지만 실체를 가지지 않는다.<br/>
클래스를 이용해 만든 객체가 실체를 가진다.<br/>


	string str1 = "ABC";
	string str2 = "가나다";



C#에서 이미 정의된 string은 문자열을 다루는 클래스다<br/>
위의 str1과 str2는 객체이다.<br/>
string은 문자열을 담는 객체를 위한 청사진이고,<br/> 
str1과 str2는 실제로 데이터를 담을 수 있는 객체이다.<br/>

클래스는 데이터와 메소드를 묶는 집합이다.<br/>
코드입장에서 클래스를 보면 기본 데이터 형식을 조합해서 만드는 복합 데이터 형식으로도 볼 수 있다.<br/>
클래스는 아래처럼 선언하고 생성할 수 있다.<br/>


	class 클래스_이름
	{

	    // 필드
	    한정자 자료형 변수명;
	    한정자 자료형 변수명;
	    ...

	    // 메소드
	    접근_제한자 반환형 메소드_이름 ( 매개변수_목록 )
	    {

	        // 메소드 기능
	        ...
	    }
	}

	static void Main()
	{

	    ...
	    클래스_이름 객체_변수명 = new 클래스이름();
	    ...
	}


클래스는 복합 데이터 형식이다. 그리고 클래스는 참조 형식이다.<br/>
참조 형식이므로 객체_변수명은 단순히 객체가 있는 곳을 가리킬 뿐이다.<br/>
단순 클래스를 선언하는 경우 가리키는 대상이 없다는 의미로 null 을 갖는다.<br/>


## 멤버
클래스안에 선언된 변수들을 일컬어 필드(Field)라고 한다.<br/>
그리고 필드와 메소드를 비롯하여 프로퍼티, 이벤트 등 클래스 내에 선언된 요소들을 일컬어 멤버(Member)라고 말한다.<br/>


## 생성자
위에서 클래스_이름()은 생성자(Constructor)라고 하는 특별한 메소드이다.<br/>
생성자는 클래스의 이름과 동일한 이름을 가지며, 객체를 생성하는 역할을 한다.<br/>


new 키워드는 생성자를 호출해서 객체를 생성하는데 사용하는 연산자이다.<br/>
C#에서는 모든 데이터 형식은 생성자와 new 연산을 이용해 생성할 수 있다.<br/>
new 연산자와 생성자는 힙에 객체를 생성하고 생성된 객체_변수명은 힙에 생성한 객체를 가리킨다.<br/>


int, float등과 같은 데이터도 생성자를 갖고 있다.<br/>


	int a = new int();
	a = 3;
	string b = new string(new char[] { '한', '글' });


생성자의 선언형식은 다음과 같다.<br/>


	class 클래스_이름
	{

	    한정자 클래스_이름( 매개변수_목록 )
	    {

	        // 기능
	        ...
	    }

	    // 필드
	    ...
	    // 메소드
	    ...
	}


생성자는 반환 형식이 없다. 생성자의 임무는 클래스의 객체를 생성하는 것뿐이기 때문이다.<br/>
클래스를 선언할 때 명시적으로 생성자를 구현하지 않아도 컴파일러에서 생성자를 만들어 준다.<br/>
이런 생성자를 기본 생성자(Default Constructor)라고 하며, 객체를 default 값으로 채워 생성할 뿐 아무런 기능이 없다.<br/>
생성자는 오버로딩이 가능해 객체의 필드를 원하는 값으로 초기화하고 싶을 때 초기화할 수 있는 최적의 장소이다.<br/>


프로그래머가 생성자를 하나라도 직접 정의하는 경우 C# 컴파일러는 매개변수 없는 기본 생성자를 제공하지 않는다.<br/>
프로그래머가 하나라도 생성자를 정의했다는 것은 객체가 특정한 상태로 초기화되를 원한다는 뜻으로 해석되기 때문이다.<br/>
이에 C# 컴파일러는 프로그래머의 의도와 다르게 동작하는 코드가 제공되는 것을 방지하기 위해 기본 생성자를 제공하지 않는것 뿐이다.<br/>


## 종료자
클래스의 이름 앞에 ~를 붙인 꼴인 메소드다.<br/>
종료자는 생성자와 달리 매개변수도 없고, 한정자도 사용하지 않는다.<br/>
종료자를 만드는 오버로딩도 불가능하며 직접 호출할 수도 없다.<br/>
종료자는 CLR의 가비지 컬렉터가 객체가 소명되는 시점을 판단해서 종료자를 호출해준다.<br/>

CLR의 가비지 컬렉터가 언제 동작할지 예측할 수 없어 종료자는 가급적 사용하지 않는게 좋다고 한다.<br/>
종료자를 명시적으로 정의하면 클래스의 족보를 타고 올라가 Finalize() 메소드를 호출한다.<br/>
그런데 이렇게 하면 응용프로그램의 성능 저하를 초래할 확률이 높다.<br/>
CLR의 가비지 컬렉터는 훨씩 똑똑하게 객체의 소멸을 처리할 수 있어 소멸자 부분은 가비지 컬렉터에 맡기는 편이 좋다.<br/>


## 정적 필드와 메소드
static은 사전저긍로 정적 이라는 뜻을 갖고 있다.<br/>
C#에서 static은 메소드나 필드가 클래스의 인스턴스가 아닌 클래스 자체에 소속되도록 지정하는 한정자이다.<br/>


static으로 한정하지 않은 필드는 자동으로 인스턴스에 소속되며,<br/>
static으로 한정한 필드는 클래스에 소속된다.<br/>

static으로 수식한 필드는 프로그램 전체에 걸쳐 공유해야 하는 변수가 있다면 정적 필드를 이용해야한다.<br/>


## 얕은 복사와 깊은 복사
클래스는 태생이 참조형식이라 클래스가 생성될 때 힙 영역에 객체를 할당하고, 스택에 있는 클래스 변수는 힙 영역에 할당된 메모리를 가리킨다.<br/>


	class ClassA
	{

	    // 필드
	    public int a;
	}

	static void Main()
	{
	
	    ClassA src = new ClassA();
	    ClassB dst = src;
	}


위와 같이 할당 연산자 =로 dst에 src 클래스를 복사하는 경우 힙에 있는 같은 객체를 참조하는 현상이 일어난다.<br/>
이를 얕은 복사라 한다. dst에 필드의 값을 수정해도 src역시 같은 객체를 가리키므로 같은 필드 값을 출력하게된다.<br/>
완전히 새로운 객체를 만들고 싶다면 깊은 복사를 수행하는 코드로 만들어야 한다.<br/>
이는 새로운 객체를 힙 영역에 할당한 뒤 필드 값을 복사하면 된다.<br/>


	class ClassA
	{

	    // 필드
	    public int a;

	    ClassA Clone()
	    {

	        ClassA dst = new ClassA();
	        dst.a = this.a;
	        return dst;
	    }
	}

	static void Main()
	{
	
	    ClassA src = new ClassA();
	    ClassB dst = src.Clone();
	}


위 처럼 새로운 객체를 만든뒤 복사하면 dst의 필드값을 새로운 값으로 변화해도 src의 값은 변하지 않는다.<br/>
단순히 Clone 메소드를 만들어 구현하는 것보다는 ICloneable 인터페이스를 상속하여 Clone 메소드를 정의 하는게 클래스를 분석하는 가독성에 좋다.<br/>
this 키워드는 아래서 다룬다.<br/>


## this
객체 외부에서는 객체의 필드나 메소드에 접근할 때 객체의 이름(변수 또는 식별자)을 사용한다면,<br/>
객체 내부에서는 자신의 필드나 메소드에 접근할 때 this 키워드를 사용한다.<br/>
this는 객체가 자신을 지칭하는 키워드이다.<br/>
this를 이용하면 메소드에서 매개변수와 필드 이름이 같은 경우 모호성을 풀 수 있다.<br/>


## this() 생성자
this가 객체 자신을 지칭하는 키워드인 것처럼, this()는 자기자신의 생성자를 가리킨다.<br/>
this()는 생성자에서만 사용할 수 있고, 사용하면 생성자들간 중복되는 코드를 제거할 수 있다.<br/>


	class ClassA
	{
	
	    int a, b, c;
	
	    ClassA()
	    {
	
	        this.a = 1;
	        Console.WriteLine("ClassA()");
	    }
	    
	    ClassA(int b) : this()
	    {
	
	        this.b = b;
	        Console.WriteLine("ClassA(int)");
	    }
	
	    classA(int b, int c) : this(b)
	    {

	        this.c = c;
	        Console.WriteLine("ClassA(int, int)");
	    }
	}

## 접근 한정자
객체지향 프로그래밍에서 클래스의 사용자에게 필요한 최소한의 기능만 노출하고 내부를 감출 것을 요구한다.<br/>
이것을 은닉성(Encapsulation)이라고 한다.<br/>

이외에도 상속성(Inheritance)과 다형성(Polymorphism)이 있고 아래에서 설명한다.<br/>

클래스에서 필드는 상수를 제외하고는 무조건 감추는게 좋다.<br/>


접근 한정자(Access Modifier)는 감추고 싶은 것은 감추고, 보여주고 싶은 것은 보여줄 수 있도록 코드를 수식한다.<br/>
필드, 메소드를 비롯해 프로퍼티 등 모든 요소에 사용할 수 있다.<br/>

접근 한정자는 모두 6가지이며 아래와 같다.<br/>


|접근 한정자|기능|
|:---:|:---|
|public|클래스의 내부, 외부 모든 곳에서 접근할 수 있다.|
|protected|클래스 외부에서는 접근할 수 없지만, 파생 클래스에서는 접근이 가능하다.|
|private|클래스 내부에서만 접근할 수 있다. 파생 클래스에서도 접근이 불가능하다.|
|internal|같은 어셈블리에 있는 코드에서만 public으로 접근할 수 있다. 다른 어셈블리 코드에서는 private와 같은 수준의 접근성을 가진다.|
|protected internal|같은 어셈블리에 있는 코드에서만 protected로 접근할 수 있다. 다른 어셈블리에 있는 코드에서는 private와 같은 수준의 접근성을 가진다.|
|private protected|같은 어셈블리에 있는 클래스에서 상속받은 클래스 내부에서만 접근이 가능하다.|


클래스 내부에서 한정자를 설정하지 않으면 private와 같은 공개 수준을 갖는다<br/>


## 상속
클래스는 다른 클래스로부터 필드, 메소드, 그리고 프로퍼티 등과 같은 멤버를 물려 받을 수 있다.<br/>
객체지향 프로그래밍에서는 물려받는 클래스를 자식 클래스 또는 파생 클래스(Derived Class)라고 한다.<br/>
물려주는 클래스를 부모 클래스 또는 기반 클래스(Base Class)라고 한다.<br/>

파생 클래스의 이름 뒤에 콜론(:)을 붙이고 상속받을 기반 클래스를 추가하면 된다.<br/>


	class Parent
	{

	    // 부모 클래스
	    Parent()
	    {

	    }

	    public void ParentMethod()
	    {

	    }
	}
	
	class Child : Parent
	{

	    // 자식 클래스
	    Child() : base()
	    {

	    }

	    public void ChildMethod()
	    {

	    }
	}


위처럼 사용하면 상속받을 수 있다.<br/>
this는 객체 자신을 나타내는 것을 의미했다. base는 부모 클래스를 나타낸다.<br/>
this()는 자신의 생성자를 의미하므로 똑같이 base()는 부모 클래스의 생성자를 나타낸다.<br/>
그리고 Child 클래스를 생성하면 Parent() -> Child() 순으로 생성자가 호출된다.<br/>
소멸자에는 따로 base() 접근이 필요없이 ~Parent() -> ~Child() 순으로 진행된다.<br/>

클래스를 만들었는데 파생 못하게도 할 수 있다.<br/>
sealed 키워드를 이용해 클래스 A를 정의하면 해당 클래스 A는 부모클래스가 될 수 없다는 의미이다.<br/>
즉, B 클래스를 정의 할 때 A 클래스를 부모 클래스로 만들려고 하면 컴파일 에러를 일으킨다.<br/>


## 부모 클래스와 자식 클래스간 형식 변환
자식 클래스는 부모 클래스로 족보를 오르내리는 형식 변환이 가능하다.<br/>
자식 클래스의 인스턴스는 부모 클래스의 인스턴스로 사용할 수 있다.<br/>

이는 메소드의 오버로딩을 줄일 수 있다.<br/>
C#은 형식 변환을 위해 is와 as 연산자 두 개를 제공한다.<br/>


|연산자|기능|
|:---:|:---|
|is|객체가 해당 형식에 해당하는지 검사하여 그 결과를 bool 값으로 반환한다.|
|as|형식 변환 연산자와 같은 역할을 한다. 형식 변환 연산자는 변환에 실패하는 경우 예외를 던지는 반면, as 연산자는 객체 참조를 null로 만든다.|


형식 연산자는 소괄호를 이용한 방법이다 ( 변환할_데이터_타입 )변환할_변수<br/>
소괄호를 이용한 형식 변환 대신 as 연산자를 사용하면 형식 변환에 실패하더라도 예외가 일어나 코드 실행이 점프하는 일이 없어 관리에 좋다.<br/>


## 다형성
객체지향 프로그래밍에서 다형성(Polymorphism)은 객체가 여러 형태를 가질 수 있음을 의미한다.<br/>
다형성은 하위 형식 다형성(Subtype Polymorphism)의 준말이다.<br/>
이는 부모 클래스로부터 만들어진 자식 클래스를 통해 다형성을 실현한다.<br/>

다형성을 적용할 메소드는 재정의해야 한다. 즉, 메소드에 오버라이딩(Overriding)을 해줘야한다.<br/>
다형성을 적용할 부모 클래스의 메소드는 virtual 선언이 필요하다. 자식 클래스에서는 overiide 키워드를 이용해 재정의 하면 된다.<br/>
다만 부모 클래스에 적용할 다형성 메소드가 private 선언이 되어있다면 자식 클래스에서는 해당 메소드가 없으므로 다형성을 적용할 수 없다.<br/>


## 메소드 숨기기
메소드가 향후 오버라이딩 될지 안될지를 판단하는 것은 공식이 없다.<br/>
그래서 C#은 프로그래머를 위해 메소드 숨기기(Method Hidding)을 사용할 수 있다.<br/>
메소드 숨기기란 CLR에게 부모 클래스에서 구현된 버전의 메소드를 감추고 자식 클래스에서 구현된 버전만 보여주는 것을 말한다.<br/>
new 한정자를 이용해 메소드 숨기기 기능을 할 수 있다.<br/>

메소드 숨기기는 오버라이딩과 다르다.<br/>
메소드 숨기기는 완전한 다형성을 표현하지 못하는 한계가 있다.<br/>


## 오버라이딩 봉인하기
sealed 키워드를 이용해 클래스를 상속이 안되게 봉인하는 것처럼 메소드도 봉인할 수 있다.<br/>
virtual로 선언되지 않으면 알아서 봉인이 되기에 virtual로 선언된 가상 메소드를 오버라이딩한 버전의 메소드만 봉인이 가능하다.<br/>

상속받은 메소드를 오버라이딩 했는데, 오작동을 하게되면 프로그래머는 객체가 원하는 대로 동작하지 않는 원인을 찾기 힘들다.<br/>
그래서 오작동 위험이 있거나 잘못 오버라이딩함으로써 문제가 생길 수 있다면 메소드를 봉인해 사전에 방지하는게 좋다.<br/>


## 읽기 전용 필드
상수는 변치 않는 데이터를 담는다. 상수는 프로그램이 실행되기 전부터 이미 정해져 있고, 프로그램 중에는 절대 그 값을 바꿀 수 없다.<br/>
읽기 전용 필드는 클래스나 구조체의 멤버로만 존재할 수 있으며 생성자 안에서 한 번값을 지정하면, 그 후로는 값을 변경할 수 없는 것이 특징이다.<br/>
생성자 이외에 값을 변경하려고 하면 컴파일 에러를 일으킨다.<br/>
읽기 전용 필드는 readonly 키워드를 이용해 선언 가능하다.<br/>


## 중첩 클래스
중첩 클래스(Nested Class)는 클래스 안에 선언되어 있는 클래스를 말한다.<br/>
클래스 안에 다른 클래스를 선언하는 것이 전부다.<br/>
다른 클래스와 다른 점이 있다면, 자신이 소속된 클래스의 멤버에 접근 한정자에 상관없이 자유롭게 접근할 수 있다.<br/>
이는 은닉성을 무너뜨리지만 유연한 표현력을 가져다준다는 장점이 있다.<br/>

중첩 클래스는 클래스를 외부에 공개하고 싶지 않은 형식을 만들거나 클래스의 일부분처럼 표현할 수 있는 클래스를 만들고자 할 때 사용된다.<br/>