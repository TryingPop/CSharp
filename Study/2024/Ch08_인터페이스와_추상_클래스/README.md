# Ch08 인터페이스와 추상 클래스
## 인터페이스
인터페이스(Interface)는 interface 키워드를 이용해서 선언한다.<br/>
선언은 클래스와 비슷하지만 메소드, 이벤트, 인덱서, 프로퍼티만을 가질 수 있다.<br/>

그리고 클래스는 접근 제한 한정자를 붙이지 않으면 private이다.<br/>
인터페이스는 접근 제한 한정자를 사용할 수 없고 public으로 선언된다.<br/>
인터페이스는 인스턴스를 만들 수 없지만 상속받는 클래스의 인스턴스를 만드는 것은 가능하다.<br/>


	interface IMyInterface
	{
	
	    // public int val;    // CS0525 컴파일 에러 발생
	    int PublicMethod();
	}
	
	class MyClass : IMyInterface
	{
	
	    public int PublicMethod()
	    {
	    
	        ...
	    }
	}
	
	static void Main()
	{
	
	    IMyInterface obj = new MyClass();
	}


위와 같은 형태로 사용하고, 인터페이스의 이름 앞에 I를 붙이는 겉이 관례이다.<br/>
인터페이스는 하나의 약속이다. 이 약속은 인터페이스로부터 파생될 클래스는 반드시 어떤 메소드를 구현해야할지를 정의해야한다.<br/>


인터페이스를 상속할 수 있는건 클래스뿐 아니라 구조체는 물론 인터페이스도 인터페이스를 상속할 수 있다.<br/>

인터페이스에 새로운 기능을 추가한 인터페이스를 만들고 싶을 때 주로 인터페이스를 상속한다.<br/>
인터페이스를 수정해도 상관없지만 .NET SDK 에서 제공하는 인터페이스들은 수정을 못하고,<br/>
혹은 해당 인터페이스를 상속한 클래스들이 다수 존재하고 확장 기능을 사용하지 않는 클래스가 존재하면 수정을 못한다.<br/>


## 다중 상속
클래스는 다중 상속을 지원하지 않는다. 이는 부모 클래스는 두 명 이상 선언할 수 없다.<br/>
두 클래스에 메소드 이름이 같고 자식에도 접근할 수 있는 메소드가 있는 경우, 어느 것을 선택해야할지 모호하기 때문이다.<br/>
반면 인터페이스는 다중 상속을 지원하는데, 인터페이스는 내용이 아닌 외형만 전달하기에 위 문제가 없다.<br/>
다양한 클래스를 상속받고 싶다면 포함(Containment)이라는 기법을 사용하는데, 물려받고 싶은 기능을 가진 클래스들을 필드로 선언하는 것이다.<br/>