# Ch08 인터페이스와 추상 클래스
## 인터페이스
인터페이스(Interface)는 interface 키워드를 이용해서 선언한다.<br/>
선언은 클래스와 비슷하지만 메소드, 이벤트, 인덱서, 프로퍼티만을 가질 수 있다.<br/>

그리고 클래스는 접근 제한 한정자를 붙이지 않으면 private이다.<br/>
인터페이스는 접근 제한 한정자를 사용할 수 없고 public으로 선언된다.<br/>
인터페이스는 인스턴스를 만들 수 없지만 상속받는 클래스의 인스턴스를 만드는 것은 가능하다.<br/>


	interface IMyInterface
	{
	
	    // public int val;    // CS0525 컴파일 에러 발생
	    int PublicMethod();
	}
	
	class MyClass : IMyInterface
	{
	
	    public int PublicMethod()
	    {
	    
	        ...
	    }
	}
	
	static void Main()
	{
	
	    IMyInterface obj = new MyClass();
	}


위와 같은 형태로 사용하고, 인터페이스의 이름 앞에 I를 붙이는 겉이 관례이다.<br/>
인터페이스는 하나의 약속이다. 이 약속은 인터페이스로부터 파생될 클래스는 반드시 어떤 메소드를 구현해야할지를 정의해야한다.<br/>


인터페이스를 상속할 수 있는건 클래스뿐 아니라 구조체는 물론 인터페이스도 인터페이스를 상속할 수 있다.<br/>

인터페이스에 새로운 기능을 추가한 인터페이스를 만들고 싶을 때 주로 인터페이스를 상속한다.<br/>
인터페이스를 수정해도 상관없지만 .NET SDK 에서 제공하는 인터페이스들은 수정을 못하고,<br/>
혹은 해당 인터페이스를 상속한 클래스들이 다수 존재하고 확장 기능을 사용하지 않는 클래스가 존재하면 수정을 못한다.<br/>


## 다중 상속
클래스는 다중 상속을 지원하지 않는다. 이는 부모 클래스는 두 명 이상 선언할 수 없다.<br/>
두 클래스에 메소드 이름이 같고 자식에도 접근할 수 있는 메소드가 있는 경우, 어느 것을 선택해야할지 모호하기 때문이다.<br/>
반면 인터페이스는 다중 상속을 지원하는데, 인터페이스는 내용이 아닌 외형만 전달하기에 위 문제가 없다.<br/>
다양한 클래스를 상속받고 싶다면 포함(Containment)이라는 기법을 사용하는데,<br/>
물려받고 싶은 기능을 가진 클래스들을 필드로 선언하는 것이다.<br/>


## 인터페이스 기본 구현 메소드
인터페이스에도 기본 메소드를 구현할 수 있다. 이 경우 인터페이스에 새로운 함수를 추가할 때 컴파일 에러를 피해갈 수 있다.<br/>
하지만 인터페이스 참조로 업캐스팅을 했을때만 사용할 수 있다.<br/>


## 추상 클래스
추상 클래스는 구현을 가질 수 있다. 하지만 클래스와 달리 인스턴스를 가질 수 없다.<br/>
추상 클래스는 구현을 갖되 인스턴스를 만들 수 없다.<br/>


	abstract class 클래스_이름
	{
	
	    // 추상 메소드
	    접근_제한_한정자 abstract 반환_형식 추상_메소드_이름( 매개변수_목록 );
	}


abstract 한정자와 class 키워드를 통해 추상 클래스를 구현할 수 있다.<br/>
추상 클래스에서는 추상 메소드(Abstract Method)를 가질 수 있다.<br/>
추상 메소드는 추상 클래스가 인터페이스 역할도 할 수 있게 해주는 장치이다.<br/>

추상 클래스는 한정자를 따로 정의하지 않으면 private이지만 추상 메소드는 private 한정자를 이용할 수 없다.<br/>


추상 클래스를 이용해 직접 인스턴스화 하지말고 자식 클래스를 이용해 사용하라고 하고,<br/>
특정 메소드를 꼭 오버라이딩 해야한다고 강제할 수 있다.<br/>