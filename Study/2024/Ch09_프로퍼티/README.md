# Ch09 프로퍼티
## 프로퍼티
객체지향 언어라면 은닉성을 표현할 수 있어야 한다.<br/>
private, protected, public 접근 한정자를 이용해 은닉성을 표현할 수 있지만 C#에서는 프로퍼티로 은닉성을 구현할 수 있다.<br/>

프로퍼티 선언은 다음과 같다.<br/>


	class 클래스_이름
	{
	
	    데이터_형식 필드_이름
	    접근_한정자 데이터_형식 프로퍼티_이름
	    {
	    
	        get { return 필드_이름; }
	        set { 필드_이름 = value; }
	    }
	}


프로퍼티 선언 문법에서 get { ... }, set { ... }을 일컬어 접근자(Accessor)라고 한다.<br/>
get 은 필드로부터 값을 읽어오고 set 은 필드에 값을 할당한다ㅏ.<br/>

프로퍼티를 통해 필드가 변경되지 않기를 바란다면 set을 정의하지 않으면 된다.<br/>


## 자동 구현 프로퍼티
C# 3.0부터 자동 구현 프로퍼티(Auto-Implemented Property)를 지원한다.<br/>
자동 구현 프로퍼티를 사용하면 컴파일러가 알아서 변수를 생성하고 프로퍼티로 해당 변수에 접근할 수 있게 한다.<br/>
그래서 필드를 선언할 필요도 없고, 그저 get 접근자와 set 접근자 뒤에 세미콜론(;)만 붙여주면 된다.<br/>


## 프로퍼티와 생성자
프로퍼티는 객체를 생성할 때 초기화할 수 있다.<br/>


	클래스_이름 인스턴스 = new 클래스_이름()
	{
	
	    프로퍼티1 = 값1,
	    프로퍼티2 = 값2
	};


위처럼 생성과 동시에 원하는 값으로 초기화할 수 있다.<br/>
모든 프로퍼티를 초기화할 필요는 없고, 원하는 프로퍼티들만 초기화하면 된다.<br/>
구조체에서는 readonly 키워드를 통해 생성자부분에서만 값을 수정하게 할 수 있었다.<br/>
프로퍼티도 init 키워드를 이용해 생성시에만 수정하게 할 수 있다.<br/>


## 레코드  형식으로 만드는 불변 객체
불변(Immutable) 객체는 내부 상태(데이터)를 변경할 수 없는 객체를 말한다.<br/>
상태를 변경할 수 없다는 특성 때문에 불변 객체에서는 데이터 복사와 비교가 많이 이뤄진다.<br/>

레코드는 새로운 상태를 표현하려고 기존 상태를 복사한 뒤 일부를 수정해 새로운 객체를 만들고,<br/>
상태를 확인하기 위해 객체 내용을 자주 비교하는데 편리하게 수행할 수 있게 한다.<br/>

레코드는 C# 9.0에서 도입된 형식이다.<br/>
앞에서 불변 객체를 만드는 방법으로 readonly 구조체를 이용하는 방법이 있었다.<br/>
readonly struct는 값 형식이므로 필드 요소가 많으면 복사 비용이 커지고 여러 곳에서 사용하면 비용도 커진다.<br/>
참조 형식은 주소만 복사하면 되기에 이런 오버헤드가 없다.<br/>

값 형식 객체를 비교할 때 기본적으로 모든 필드를 1:1비교한다ㅏ. 불변 객체 비교에 필요한 방법이다.<br/>
클래스로 불변 객체를 만든다면 Equals() 메소드를 오버라이딩 해서 구현해야 한다.<br/>
불변 객체를 참조형식으로 선언하면 함수 호출 인수나 컬렉션 요소로 사용할 때 복사 비용을 줄일 수 있다.<br/>
레코드 형식은 이러한 불편함을 해소한 값 형식처럼 다룰 수 있는 불변 참조 형식이다.<br/>

선언은 record 키워드를 이용하면 된다.<br/>


	record 레코드_이름
	{
	
	    // 필드
	    public int Val1 { get; init; }
	    public int Val2 { get; set; }
	}


레코드에는 초기화 전용 자동 구현 프로퍼티뿐만 아니라 쓰기 가능한 프로퍼티와 필드도 자유롭게 선언해 넣을 수 있다.<br/>

C# 컴파일러는 레코드 형식을 위한 복사 생성자를 자동으로 작성한다.<br/>
복사 생성자는 protected이기 때문에 명시적으로 호출할 수 없고 with 식을 이용해야 한다.<br/>


	record 레코드_이름
	{
	
	    public int Val1 { get; init; }
	    public int Val2 { get; init; }
	}
	
	static void Main()
	{
	
	    레코드_이름 변수명1 = new 레코드_이름 { Val1 = 10 };
	    레코드_이름 변수명2 = 변수명1 with { Val2 = 40 };
	}


위처럼 변수명2는 변수명1의 모든 상태를 복사한 다음 Val2 프로퍼티만 40으로 수정한다.<br/>
레코드는 앞에서 말했다싶이 따로 Equals() 메소드를 구현하지 않아도 Equals()는 필드끼리 비교하는 메소드가 된다.<br/>


## 무명 형식
형식의 이름을 이용해서 인스턴스를 만들기 때문에 형식의 이름은 필요하다.<br/>
C#에는 이름이 없는 형식, 즉 무명 형식(Anonymous Type)이 있다.<br/>
무명 형식은 형식의 선언과 동시에 인스턴스를 할당한다. 그래서 인스턴스를 만들고 다시 사용하지 않을 때 유용하다.<br/>
무명 형식은 초기화에서만 값을 할당할 수 있고 이후에는 변경이 불가능하다.<br/>


## 인터페이스와 프로퍼티
인터페이스는 메소드 뿐만 아니라 프로퍼티나 인덱서를 가질 수 있다.<br/>
인터페이스에 들어가는 프로퍼티는 구현을 갖지 않는다.<br/>
인터페이스의 프로퍼티 선언은 클래스의 자동 구현 프로퍼티 선언과 그 모습이 동일하다.<br/>
인터페이스의 프로퍼티는 인터페이스의 메소드처럼 자식 클래스에서 프로퍼티를 정의해줘야 한다.<br/>


## 추상 클래스의 프로퍼티
추상 클래스는 클래스 형식의 프로퍼티나 인터페이스 형식의 프로퍼티 둘 다 가질 수 있다.<br/>
인터페이스에서 구현되지 않은 프로퍼티를 추상 프로퍼티(Abstract Property)라고 한다.<br/>
추상 프로퍼티는 abstract 키워드를 이용해 정의하면 된다.


	abstract class 추상_클래스_이름
	{
	
	    abstract 데이터의_형식 프로퍼티 이름 { get; set; }
	}