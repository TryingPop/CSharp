# Ch19 스레드와 태스크
## 프로세스와 스레드
프로세스(Process)는 실행 파일이 실행되어 메모리에 적재된 인스턴스이다.<br/>
프로세스는 반드시 하나 이상의 스레드(Thread)로 구성되는데, 스레드는 운영체제가 CPU 시간을 할당하는 기본 단위다.<br/>


## 멀티 스레드
멀티 스레드의 장점은 다음과 같다.<br/>

  1. 응답성을 높일 수 있다.
    - 단일 프로그램에서는 하나의 장기간 작업을 시작하면 중간에 취소하고 싶어도 못하지만 멀티 스레드에서는 가능하다.
  2. 자원 공유가 쉽다.
    - 멀티 프로세스는 IPC(Inter Process Communication)을 이용해 자원 공유를 하는데 스레드는 스택 이외에 다른 메모리를 공유해 자원 공유가 쉽다.
  3. 경제성이 좋다.
    - 프로세스를 띄우기 위해 메모리와 자원을 할당하는 작업은 비용이 비싼데, 스레드를 띄울 때는 이미 프로세스에 할당된 메모리와 자원을 그대로 사용하므로 메모리와 자원을 할당하는 비용을 지불 안해도 된다.


멀티 스레드의 단점은 다음과 같다.<br/>

  1. 구현하기가 매우 까다롭다.
  2. 멀티 프로세스에서는 하나의 프로세스가 잘못되면 하나의 프로세스만 이상이 있는데 멀티 스레드는 하나의 스레드가 잘못되면 해당 스레드를 포함한 프로세스의 스레드 모두가 잘못될 수 있다.
  3. 스레드를 너무 많이 사용하면 작업간 전환(Context Switching)으로 성능이 더 저하된다.


## 스레드
스레드는 Thread 인스턴스를 생성하고 생성자의 인수로 스레드가 실행할 메소드를 넘긴다.<br/>
Thread.Start() 메소드를 호출해 스레드를 시작하고, Thread.Join()을 이용해 스레드가 끝날 때까지 기다린다.<br/>
그리고 Abort() 메소드로 스레드를 중간에 중단 시킬 수 있던 메소드가 있었는데, 현재는 obsolete 어트리뷰트로 사용 못하게 막아놨다.<br/>


스레드의 상태는 다음과 같이 있다.<br/>
그리고 상태는 비트 필드 값 형식으로 저장되어 있다.<br/>

|상태|값|기능|
|:---:|:---:|:---|
|Unstarted|8|스레드 객체를 생성한 후 Tharead.Start() 메소드를 호출하기 전 상태|
|Running|0|스레드가 동작 중인 상태를 나타낸다.|
|Suspended|64|스레드의 일시 중단 상태를 나타낸다. Thread.Suspend() 메소드를 호출해 해당 상태로 만들 수 있고, Thread.Resume()으로 Running 상태를 만들 수 있다.|
|WaitSleepJoin|32|스레드가 블록(Block)된 상태를 나타낸다. 스레드에 의해 Thread.Sleep 또는 Thread.Join 또는 Monitor.Enter() 메소드를 호출하면 해당 상태가 된다.|
|Aborted|256|스레드가 취소된 상태를 나타낸다.|
|Stopped|16|중지된 스레드를 나타낸다. Abort 메소드나 스레드의 실행 중인 메소드가 종료되면 해당 상태가 된다.|
|Background|4|스레드가 백그라운드로 동작하고 있음을 나타낸다. 포어그라운드(Foreground)는 스레드가 하나라도 살아 있는한 죽지 않지만, 백그라운드는 몇 개가 살아있던 프로세스가 죽고 사는 것에 영향을 주지 않는다. 하지만 프로세스가 죽으면 백그라운드 스레드들도 모두 죽는다.|


스레드의 상태는 이동할 수 있는 경로가 정해져 있다.<br/>
Abort가 아닌 Thread.Interrupt() 메소드로 스레드를 중단시킬 수 있다.<br/>
Interrupt()메소드는 스레드가 Running 상태를 피해 WaitJoinSleep 상태에 들어갔을 때 ThreadInterruptedException 예외를 던져 스레드를 중단시킨다.<br/>
WaitJoinSleep상태에서는 즉시 중단시키지만 이외의 상태에서는 WaitJoinSleep 상태가 될 때까지 기다린다.<br/>
이는 절대로 중단되면 안되는 작업을 하고 있을 때 중단 안되는 즉, 안정성을 보장받는다.<br/>


## 스레드간 동기화
크리티컬 섹션(Critical Section)은 한 번에 한 스레드만 사용할 수 있는 코드영역을 말한다.<br/>
C#에서는 lock 키워드로 감싸주기만 해도 크리티컬 섹션으로 만들 수 있다.<br/>

lock을 사용하는 영역이 많아지면 성능이 크게 떨어질 수 있어 필요한 곳에만 사용하는 것이 중요하다.<br/>
그리고 lock에 전달하는 키워드도 외부에서 접근 불가능한 키워드가 좋다.<br/>
this, 클래스 형식, 문자열 형식이 대표적으로 피해야할 예이다.<br/>

Monitor 클래스는 스레드 동기화에 사용하는 정적 메소드를 제공한다.<br/>
Monitor.Enter()와 Monitor.Exit()이 있다. lock과 같다고 보면 된다.<br/>
lock은 Monitor 클래스의 Enter와 exit 메소드를 바탕으로 구현되어 있어 lock 키워드를 이용하는게 간편하다.<br/>
Monitor를 이용할 때는 예외가 발생하는 경우 finally로 키를 해제하는 작업을 추가해야한다!<br/>

Monitor를 쓰는 이유는 Wait()과 Pulse() 메소드를 쓰기위해 주로 사용한다.<br/>
Wait을 사용하면 스레드를 WaitSleepJoin 상태로 만든다. WaitSleepJoin 상태에 들어간 스레드는 동기화를 위해 락(lock)을 내려놓은 뒤 Waiting Queue라고 하는 큐에 입력된다.<br/>
그리고 다른 스레드가 락을 얻어 작업을 수행한다.<br/>
락을 얻은 스레드가 작업이 끝나면 Pulse() 메소드를 호출하면 CLR은 Waiting Queue에서 첫 번째 위치에 있는 스레드를 꺼낸 뒤 Read Queue에 입력 시킨다.<br/>
Ready Queue에 입력된 스레드는 입력된 차례에 따라 락을 얻어 Running 상태에 들어간다.<br/>


Thread.Sleep() 메소드도 WaitSleepJoin 상태를 만들지만 Waiting Queue에는 들어가지 않는다.<br/>
Interrupt나 시간이 경과해야 깨어난다.<br/>

Monitor.Wait()메소드는 Monitor.Pulse() 메소드가 호출되면 바로 깨어난다.<br/>
Wait과 Pulse를 이용해 실행순서간 동기화를 할 수 있다.<br/>


## Task와 Task<TResult>
병렬 처리는 하나의 작업을 여러 작업자가 나눠서 수행한 뒤 다시 하나의 결과로 만드는 것을 병렬 처리라 한다.<br/>
반면 비동기(Asynchronous) 처리 작업은 작업 A를 실행한 후 A 작업이 끝날 때까지 기다리는게 아닌 B, C, D 작업을 하고 A 작업이 끝나면 그 작업의 결과를 받아내는 방식을 말한다.<br/>

Task는 내부적으로 Thread를 이용해 구현되어 있고, 비동기 코드를 손쉽게 만들게 해준다.<br/>
Task는 반환값이 없는 함수(Action)를 인자로 전달해 해당 함수를 비동기로 실행시킨다.<br/>


Task<TResult>는 TResult 형태의 반환값을 반환하는 Task라 보면 된다.<br/>
인자로 반환 값이 있는 함수(Func)를 비동기로 전달해 해당 함수를 비동기로 실행시킨다.<br/>
Result 프로퍼티로 결과를 받아올 수 있으며 실행이 끝나야지만 반환 받을 수 있다. 실행 중에는 반환 안된다.<br/>


## Parallel
Parallel 클래스는 For, Foreach 메소드를 제공함으로써 병렬처리를 더 쉽게 구현할 수 있게 해준다.<br/>
Parallel.For는 해당 범위안에서 병렬로 메소드를 실행한다. 스레드의 양은 알아서 판단한다.<br/>


	Parallel.For(0, 100, (int x) => { Console.Write($"{x} "); });


위와 같이 사용할 수 있다.<br/>
이는 0에서 100까지 무명 함수 (int x) => { Console.Write($"{x} "); }를 실행한다.<br/>


## async와 await
C# 5.0에서 새롭게 도입된 키워드다.<br/>
이전에는 BeginInvoke(), EndInvoke()로 비동기 작업을 처리했다.<br/>
하지만 이 패턴은 여간 까다로운게 아니라 숙련도를 필요로 한다.<br/>

async 한정자로 메소드나 태스크를 수식하기만 하면 비동기 코드로 변한다.<br/>
async로 한정하는 메소드는 반환 형식이 Task, Task<TResult>나 void로 한정된다.<br/>

C# 컴파일러는 async 한정자를 수식하는 경우 해당 메소드 안에서 await 연산자를 찾는다.<br/>
await 연산자를 찾으면 그곳에서 호출자에게 제어를 돌려주는 실행파일을 만든다.<br/>
await 이전에는 동기로 실행되며, await 이후에 비동기로 실행된다.<br/>

Task.Delay()는 시간이 지나면 Task 객체를 반환한다.<br/>
Thread.Sleep()과 유사하나 Thread.Sleep()은 스레드 전체를 블록시키는데 반해,<br/>
Task.Delay()는 스레드를 블록시키지 않는다.<br/>