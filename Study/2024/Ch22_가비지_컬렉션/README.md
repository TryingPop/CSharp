# Ch22 가비지 컬렉션
## 가비지 컬렉터
C, C++ 언어로 프로그래밍에서 메모리 관리는 꽤나 중요한 일이다.<br/>
메모리를 할당해 객체를 생성하고 객체를 다 사용하면 해당 포인터가 가리키고 있는 메모리를 해제해줘야한다.<br/>
객체 안에 힙 영역에 할당된 메모리가 있다면 해당 메모리 역시 해제해줘야 한다.<br/>
그리고 다른 객체에서 해제한 메모리를 참조하고 있는 경우 버그를 일으킬 수 있다.<br/>

그리고 C, C++ 기반의 C-런타임은 객체를 담기 휘한 메모리를 여러 개의 블록으로 나눈 뒤,<br/>
C-런타임은 링크드 리스트로 묶어 관리한다.<br/>

C-런타임은 힙에 할당하는 코드가 실행되면 링크드 리스트를 순차적으로 탐색한다.<br/>
그리고 객체를 담을 수 있을 만한 여유가 있는 메모리 블록을 찾는다.<br/>

적절한 크기의 메모리 블록을 만나면 프로그램은 이 메모리 블록을 쪼개서 객체를 할당하고 메모리 블록의 링크드 리스트를 재조정한다.<br/>
단순히 메모리 공간에 데이터를 집어넣는 것이 아니라 공간을 탐색하고 분할하고 재종하는 오버헤드가 필요하다.<br/>

반대로 C#은 CLR이 자동 메모리 관리(Automatic Memory Management)기능해 자유롭다.<br/>
자동 메모리 관리 기능의 중심에는 가비지 컬렉션(Garbage Collectiona)이 있다.<br/>
가비지 컬렉션을 담당하는 프로그램이 가비지 컬렉터(Garbage Collector)이다.<br/>
가비지 컬렉터도 소프트웨어이기 때문에 CPU나 메모리같은 자원을 사용한다.<br/>


C#의 기본 코드는 CLR에 관리되는 관리형 코드(Managed Code)이다.<br/>
C#에서 unsafe 키워드를 이용해 비관리형 Unmanaged Code도 작성할 수 있다.<br/>
비관리형인 경우 CLR 서비스를 받을 수 없다.<br/>


## 할당
참조형식의 객체가 생성되면 힙 메모리에 메모리를 순차적으로 할당한다.<br/>
msdn의 설명에 의하면 관리되는 코드에서는 할당하는 속도는 포인터만 이동시켜 매우 스택의 속도만큼 빠르다고 한다.<br/>
반면 비관리되는 코드는 관리되는 힙보다 느리다고 한다.<br/>
링크 : https://learn.microsoft.com/ko-kr/dotnet/standard/garbage-collection/fundamentals<br/>


## 해제
객체의 메모리 주소를 참조하는 객체를 일컬어 루트(Root)라고 한다.<br/>
루트는 힙에 생성될 수도, 스택에 생성될 수도 있다.<br/>

.NET 어플리케이션이 실행되면 JIT 컴파일러가 이 루트들을 목록으로 만들고,<br/>
CLR은 이 루트목록을 관리하며 상태를 갱신한다.<br/>
CLR이 관리하던 루트 목록을 참조해서 쓰레기를 수집한다.<br/>
방법은 다음과 같다.<br/>
  1. 작업 시작 전 모든 객체가 쓰레기라고 가정한다. 즉, 루트 목록 내의 어떤 루트도 메모리를 가리키지 않는다고 가정한다.
  2. 루트 목록을 순회하면서 각 루트가 참조하고 있는 힙 객체와의 관계 여부를 조사한다. 만약 루트가 참조하고 있는 힙의 객체가 또 다른 힙 객체를 참조하고 있다면 이 역시도 해당 루트와 관꼐 있는 것으로 판단한다. 이 때 어떤 루트와도 관계 없는 힙 객체들은 쓰레기로 간주한다.
  3. 쓰레기 객체가 차지하고 있던 메모리는 비어있는 공간이다.
  4. 힙을 순회하면서 쓰레기가 차지했던 비어 있는 공간에 쓰레기의 인접 객체들을 이동해서 차곡차곡 채워넣는다.


## 세대
CLR은 메모리를 0, 1, 2의 3개의 세대로 나누고 0세대는 빠르게 사라질거라 생각하는 객체들, 2세대는 오래 살아남을 것으로 예상되는 객체들로 구분한다.<br/>
각 세대별로 할당된 임계치가 넘어가면 가비지 컬렉터는 해당 세대에 가비지 컬렉션을 수행하고 여기서 살아남은 객체들은 다음 세대로 승격시킨다.<br/>
2세대로 옮겨간 객체들은 더 이상 승격되지 않는다. 그래서 2세대 가비지 컬렉션을 Full GC(Full Garbage Collection)라 한다.<br/>

힙의 각 세대는 0세대, 1세대, 2세대 순으로 가비지 컬렉션 빈도가 높다.<br/>


## 주의 사항
가비지 컬렉션을 성능 향상 시키는 방법으로는 다음과 같이 4가지 주의사항이 있다.<br/>

  1. 객체를 너무 많이 할당하면 안된다.
  2. 너무 큰 객체 할당은 피해야 한다.
  3. 너무 복잡한 참조 관계는 만들면 안된다.
  4. 루트를 너무 많이 만들면 안된다.


### 객체를 너무 많이 할당하면 안된다.

CLR의 객체 할당 속도가 빠르긴 하지만 너무 많은 수의 객체는 각 세대에 메모리 포화를 초래하고 빈번한 가비지 컬렉션 호출로 이뤄진다.<br/>


### 너무 큰 객체 할당은 피해야 한다.

CLR은 85kb 이상의 대형 객체를 할당하기 위한 대형 객체 힙(LOH, Large Object Heap)을 따로 유지한다.<br/>
평소에 사용하는 힙을 소형 객체 힙(SOH, Small Object Heap)이라고 부르기도 한다.<br/>

대형 객체를 소형 객체에 할당하게되면 가비지 컬렉션을 자주 촉발하게 되어 구분된다.<br/>
대형 객체는 힙 할당에서 객체 크기를 계산한 뒤 그만한 여유 공간이 있는지 힙을 탐색하여 할당한다.<br/>

소형 객체 힙은 차곡차곡 정리하지만, 대형 객체 힙은 해제된 공간을 그대로 둔다.<br/>
정리하기에는 메모리 복사 비용이 너무나도 비싸기 때문이다. 이후 다른 객체들에 할당은 된다.<br/>


### 너무 복잡한 참조 관계는 만들면 안된다.

참조관계가 많은 객체는 살아남았을 때 객체의 세대를 옯기기 위해 메모리 복사를 수행하게 된다.<br/>
이 대 참조관계를 일일히 조사해서 참조하고 있는 메모리의 주소를 저눕 수정하기에 비용이 더 들어간다.<br/>

다른 세대의 객체를 잠조하는 경우 쓰기 장벽(Write barrier)라는 장치를 통해 가비지 컬렉터로 하여금 수거를 방지하는데,<br/>
쓰기 장벽을 생성하는데 드는 오버헤드가 크다.<br/>


### 루트를 너무 많이 만들면 안된다.

루트가 작아지면 그만큼 검사를 수행하는 횟수가 줄어들어 속도가 빨라지게 된다.<br/>